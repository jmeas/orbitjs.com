const fs = require('fs');
const del = require('del');
const _ = require('lodash');
const gulp = require('gulp');
const mkdirp = require('mkdirp');
const Handlebars = require('handlebars');
const loadPlugins = require('gulp-load-plugins');
const execSync = require('child_process').execSync;
const marked = require('marked');
const highlight = require('highlight.js');

// Configure Marked to highlight our code blocks
marked.setOptions({
  highlight: function (code) {
    return highlight.highlightAuto(code, ['javascript']).value;
  }
});

// Load the Gulp plugins under the variable `$`
const $ = loadPlugins({
  rename: {
    'gulp-json-transform': 'transformJson'
  }
});

// Get the commit that we're building the docs from
var sha = execSync('cd ../orbit.js && git rev-parse HEAD', {encoding: 'utf8'});
sha = sha.replace(/\s$/, '');

// Takes the relative path generated by YUIDoc and makes it absolute
const githubUrl = 'http://github.com/orbitjs/orbit.js/blob/' + sha + '/';
const repoName = 'orbit.js';

// Takes an absolute path of a library file on this computer, and
// returns the path relative to the root of the orbitjs repository.
function relativeFilePath(url) {
  var lastIndex = url.lastIndexOf(repoName);
  return url.slice(lastIndex + repoName.length + 1);
}

// Updates a URL for a library file to point to where it's located on Github
function createGithubUrl(url) {
  return githubUrl + relativeFilePath(url);
}

// Takes an object that might have markdown fields and converts those
// fields to HTML. This is necessary because Jekyll's built-in markdown parser
// will ignore Markdown that is nested within HTML elements.
function transformMarkdownFields(obj) {

  // These are property keys that are Markdown strings
  var markdownKeys = ['description'];
  // and these are property keys that are arrays of Markdown strings
  var markdownArrays = ['example'];

  _.each(markdownKeys, function(key) {
    if (!obj[key]) { return; }
    obj[key] = marked(obj[key]);
  });

  _.each(markdownArrays, function(key) {
    if (!obj[key]) { return; }
    _.each(obj[key], function(item, index) {
      obj[key][index] = marked(item);
    });
  });
}

// Remove the built CSS file
gulp.task('clean-css', function(cb) {
  del('./css/style.css', cb);
});

// Remove the existing API docs file
gulp.task('clean-api-docs', function(cb) {
  del('./_data/orbitjs_api.json', cb);
});

// Remove the generated API docs file
gulp.task('clean-generated-api', function(cb) {
  del('./_data/api_data.json')
});

// Remove the generated API html files
gulp.task('clean-generated-templates', function(cb) {
  del('./api/data/*');
});

// Compile our API documentation files from the
// data file generated by YUIDoc
gulp.task('generate-api-pages', function(cb) {
  mkdirp.sync('./api/data');
  var orbitApi = require('./_data/orbitjs_api.json');

  // "classitems" is what YUIDoc calls methods, properties, and other
  // things associated with a class. We transform their properties to
  // be suitable for our Handlebars template.
  var classItems = _.chain(orbitApi.classitems)
    .filter('itemtype')
    .map(function(ci) {
      ci.relativePath = relativeFilePath(ci.file);
      ci.file = createGithubUrl(ci.file);
      ci.access = ci.access || 'public';
      transformMarkdownFields(ci);

      _.each(ci.params, function(param) {
        transformMarkdownFields(param);
      });

      return ci;
    })
    .groupBy('class')
    .value();

  // "classes" includes both Classes and Namespaces.
  var classes = _.map(orbitApi.classes, function(c) {
    var cItems = classItems[c.name];
    c.relativePath = relativeFilePath(c.file);
    c.file = createGithubUrl(c.file);
    c.methods = _.filter(cItems, {itemtype: 'method'});
    c.properties = _.filter(cItems, {itemtype: 'property'});
    c.events = _.filter(cItems, {itemtype: 'event'});
    c.apiCount = c.methods.length + c.properties.length + c.events.length;
    transformMarkdownFields(c);
    return c;
  });

  // Precompile the template used for API pages
  var templateString = fs.readFileSync('./api/template.hbs', {encoding: 'utf8'});
  var templateFn = Handlebars.compile(templateString);

  // Loop through our objects, creating a file for each one.
  _.each(orbitApi.classes, function(definition, name) {
    _.extend(definition, {name: name});
    var result = templateFn(definition);
    var filename = './api/data/' + name + '.md';
    fs.writeFileSync(filename, result);
  });

  cb();
});

// Compile Stylus
gulp.task('stylus', function() {
  return gulp.src('./css/stylus/index.styl')
    .pipe($.stylus())
    .pipe($.rename('style.css'))
    .pipe(gulp.dest('./css'));
});

// Generate the API docs from the source library. For this
// to work, the main orbit repo must be in a sibling directory
// to this repository.
gulp.task('fetch-api-docs', function() {
  return gulp.src('../orbit.js/lib/**/*.js')
    .pipe($.yuidoc.parser())
    .pipe($.rename('orbitjs_api.json'))
    .pipe(gulp.dest('./_data'));
});

// After the API docs have been fetched, they need to be transformed
// for our templates to render the proper HTML
gulp.task('transform-api-docs', ['fetch-api-docs'], function() {

  // Determine whether a YUIDoc "class" definition is a namespace or not
  var filter = function(definition) {
    return definition.namespace;
  };

  return gulp.src('./_data/orbitjs_api.json')
    .pipe($.transformJson(function(data) {
      // Update all URLs to be relative to Github.com, and not your local directory
      var classes = _.map(data.classes, function(c) {
        c.file = createGithubUrl(c.file);
        return c;
      });

      // Find the namespaces
      var namespaces = _.reject(classes, filter);

      // Group the classitems by their associated Class
      var classItems = _.groupBy(data.classitems, 'class');

      // Create an object of namespaces with the classes
      // nested within them.
      return _.chain(classes)
        // Remove namespaces
        .filter(filter)
        // Attach the classItems to the Class
        .map(function(c) {
          c.classItems = classItems[c.name];
          return c;
        })
        .groupBy('namespace')
        .mapValues(function(group, name) {
          
          // Locate the correct namespace given the name of the group
          var namespace = _.findWhere(namespaces, {name: name});

          // Extend that namespace with the group
          return _.extend(namespace, {
            classes: _.sortBy(group, 'name')
          });
        })
        .value();
    }))
    .pipe($.rename('api_data.json'))
    .pipe(gulp.dest('./_data'));
});

// Automatically build the Stylus as changes are made
gulp.task('watch', function(done) {
  gulp.watch('css/stylus/*.styl', ['clean-css', 'stylus']);
  done();
});

// Build the site
gulp.task('build', ['clean-css', 'stylus', 'generate-api-pages']);

// Get the API docs in order
gulp.task('docs', ['clean-api-docs', 'clean-generated-api', 'transform-api-docs']);

// Work on the site with Watch!
gulp.task('work', ['build', 'watch']);

// An alias of build
gulp.task('default', ['build']);